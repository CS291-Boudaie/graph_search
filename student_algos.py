# Each of these should return a path from start to goal.
# Implement duplicate checking for each

def bfs(graph):
    # TODO: implement
    # Hint: The networkx tutorial gets pretty close; the slides get you there close as well.
    return []

def dfs(graph):
    # TODO: implement
    # Hint: This algorithm works very well with recursion; see the slides
    return []

# For fun you can implement iterative deepening; but it won't be graded or checked

def dijkstra(graph):
    # TODO: Implement
    # Hint: The duplicate checking can't be as strict as BFS and DFS
    # Hint 2: If you do A* first, you can implement dijkstra with A* and a heuristic that always returns 0
    return []

def a_star(graph):
    # TODO: Implement
    # Hint: See slides :)
    return []